# C++ Веб-сервис с Crow, PostgreSQL и Redis

Простой веб-сервис на C++ с фреймворком Crow, СУБД PostgreSQL (libpqxx) и кешем Redis (redis-plus-plus). Предназначен для хранения статей и комментариев с базовой функциональностью CRUD и кешированием для ускорения чтения.

## Кратко о проекте
- **Фреймворк:** Crow (HTTP-сервер).
- **База данных:** PostgreSQL с таблицами `articles` и `comments` (связь один-ко-многим).
- **Кеш:** Redis (Valkey) для хранения результатов GET-запросов.
- **Язык:** C++17.
- **Особенности:**
  - Получение списка статей с комментариями.
  - Получение одной статьи с комментариями.
  - Создание статьи и комментария.
  - Кеширование GET-ответов с TTL и инвалидацией при изменении данных.
  - Простая многопоточность Crow (`.multithreaded()`).

## Структура
- `src/main.cpp` — основной код: настройка Crow, маршруты, работа с БД и Redis.
- `CMakeLists.txt` — описание сборки проекта.
- `.gitignore` — исключение временных файлов и артефактов сборки.

## Требования
- **Компилятор:** C++17 (GCC или Clang).
- **CMake:** ≥ 3.10.
- **PostgreSQL** и **libpqxx**.
- **Redis/Valkey** и **redis-plus-plus** (hiredis).
- **Crow** (заголовочные файлы и библиотека).

## Конфигурация
Через переменные окружения:
- `DB_CONN` — строка подключения PostgreSQL, например: `host=127.0.0.1 port=5432 dbname=blogdb user=bloguser password=...`.
- `REDIS_URI` — URI Redis, например: `tcp://127.0.0.1:6379` или с паролем.
- `SERVER_PORT` (необязательно) — порт сервера, по умолчанию 18080.
- `CACHE_TTL` (необязательно) — время жизни кеша в секундах (по умолчанию 60).

Перед запуском экспортируйте:
```bash
export DB_CONN="..."
export REDIS_URI="tcp://127.0.0.1:6379"
export SERVER_PORT="18080"
export CACHE_TTL="60"
```

## Сборка и запуск
1. Клонирование и переход в директорию:
```bash
git clone git@github.com:USERNAME/REPO.git
cd REPO
```
2. Создание папки сборки и запуск CMake:
```bash
mkdir build && cd build
cmake ..
make -j$(nproc)
```
3. Запуск сервера:
```bash
./myservice
```
   Сервер слушает указанный порт, выводит логи об ошибках подключения.

## API
### GET /articles
Возвращает все статьи с комментариями. Сначала проверяется кеш (`articles_all`). Если в кеше есть результат, возвращается быстро; иначе запрашивает из БД, сохраняет в Redis с TTL.

**Ответ (200):**
```json
{
  "articles": [
    {"id":1, "title":"...", "content":"...", "comments":[{"id":...,"content":"..."}, ...]},
    ...
  ]
}
```

### GET /article/{id}
Возвращает статью с данным ID и её комментарии. Кешируется по ключу `article:{id}`.

**Ответы:**
- 200: JSON статьи.
- 404: статья не найдена.
- 500: ошибка сервера.

### POST /article
Создаёт новую статью.

**Запрос:** JSON `{ "title": "...", "content": "..." }`.
**Ответы:**
- 201: `{ "id": new_id }`, после чего инвалидируется кеш списка.
- 400: неверный запрос.
- 500: ошибка БД.

### POST /comment
Добавляет комментарий к статье.

**Запрос:** JSON `{ "article_id": <id>, "content": "..." }`.
**Ответы:**
- 201: `{ "id": new_comment_id }`, инвалидирует кеш для этой статьи (и списка при необходимости).
- 400: неверный запрос.
- 404: статья не найдена.
- 500: ошибка БД.

## Кеширование
- **Ключи:** `articles_all`, `article:{id}`.
- **TTL:** по умолчанию 60 секунд.
- **Инвалидация:** при POST-запросах удаляются соответствующие ключи.
- **Поведение при ошибках Redis:** логируются, но сервис продолжает работать с БД.

## Многопоточность и производительность
- Crow в режиме `.multithreaded()`: несколько потоков обрабатывают подключения параллельно.
- При длительных запросах можно использовать offload (пул потоков) для БД, чтобы не блокировать сетевые потоки.
- Рекомендуется реализовать пул соединений к PostgreSQL для снижения накладных расходов.

## Тестирование
- **Функциональное:** curl или Postman для проверки эндпоинтов.
- **Нагрузочное:** wrk: сравнить показатели с кешем и без.
  ```bash
redis-cli DEL articles_all
wrk -t4 -c100 -d30s http://127.0.0.1:18080/articles
# затем один GET для заполнения кеша
wrk -t4 -c100 -d30s http://127.0.0.1:18080/articles
```
- **Метрики:** отслеживайте latency и throughput.

## Лицензия
Укажите подходящую лицензию (например, MIT).

